/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package knightsTour;

import java.awt.*;
import java.util.ArrayList;
import java.util.Comparator;

public class App {

    // solve the Knights Tour using a priority matrix
    static boolean FAST_SOLUTION = true;

    // uses a better sorting solution to improve priority of the FAST_SOLUTION
    static boolean SUPER_FAST_SOLUTION = true;


    public static void main(String[] args) {

        // example: find Knights Tour solution starting at 3, 3
        ArrayList<Point> moves = search(new Point(3,3));

        // print result
        for (Point p: moves) {
            System.out.println(p.x + ", " +  p.y);
        }
    }


    /*
     * Returns a list of moves to complete the Knights Tour problem starting with start
     */
    public static ArrayList<Point> search(Point start) {

        // store the number of attempts the knight makes to move
        MutableInt count = new MutableInt(1);

        // store the moves the knight makes
        ArrayList<Point> moves = new ArrayList<>();

        moves.add(start);

        searchHelper(moves.get(0), moves.get(0), initBoard(), moves, count);

        return moves;

    }

    /*
     * @param startPos: The Point that the knight begins on the board
     * @param pos: The current position of the knight on the board
     * @param m: A 2d int array representing the priority of each space on the board, a 10 represents already traveled space
     * @param moves: A list of moves that the knight takes
     * @count: a wrapped int that counts the number of moves the knight makes including wrong paths
     */

    private static boolean searchHelper(Point startPos, Point pos, int[][] m, ArrayList<Point> moves, MutableInt count) {

        // base case
        if (moves.size() == 64) {
            return true;
        }

        m[pos.x][pos.y] = 10;

        ArrayList<Point> possibleMoves = getMoves(pos);

        if(FAST_SOLUTION || SUPER_FAST_SOLUTION) {

            // decrement the possible moves on the board from this position
            for(int i = 0; i < possibleMoves.size(); i++) {
                Point p = possibleMoves.get(i);
                if(m[p.x][p.y] != 10) {
                    m[p.x][p.y]--;
                }
            }

            // sort moves to prioritize the more difficult to reach spaces first
            possibleMoves = sort(SUPER_FAST_SOLUTION, startPos, m, getMoves(pos));

        }


        for(int i = 0; i < possibleMoves.size(); i++) {
            Point p = possibleMoves.get(i);


            // here 10 represents an already visited space, ignore 10's
            if(m[p.x][p.y] < 10) {


                // create copy of array m
                int[][] m2 = new int[m.length][m[0].length];
                for (int z = 0; z < m.length; z++) {
                    System.arraycopy(m[z], 0, m2[z], 0, m[z].length);
                }

                count.add(1);

                moves.add(p);
                if(searchHelper(startPos, p, m2, moves, count)){
                    return true;
                } else {
                    moves.remove(moves.size()-1);
                }
            }
        }
        return false;
    }


    /*
     * sorts an ArrayList of points from least to greatest using matrix m as their values
     */
    public static ArrayList<Point> sort(boolean optimizedSort, Point startPos, int[][] m, ArrayList<Point> points) {

        points.sort(new Comparator<Point>() {
            @Override
            public int compare(Point p1, Point p2) {
                if(optimizedSort && m[p1.x][p1.y] - m[p2.x][p2.y] == 0) {


                    // calculate which coordinate is closest to start position corner
                    int x, y;
                    x = startPos.x<=3?0:7;
                    y = startPos.y<=3?0:7;

                    if(x==0 && y==0)
                        return (p2.x+p2.y)-(p1.x+p1.y);
                    if(x==7 && y==7)
                        return (p1.x+p1.y)-(p2.x+p2.y);
                    if(x==7 && y==0)
                        return (p2.x-7+p2.y)-(p1.x-7+p1.y);
                    if(x==0 && y==7)
                        return (p2.x+p2.y-7)-(p1.x+p1.y-7);

                   return  0;

                } else {
                    return m[p1.x][p1.y] - m[p2.x][p2.y];
                }
            }
        });
        return points;
    }


    /*
     * returns a list of all possible moves on an 8x8 board given a Point p
     * note: does not take into account places which have already been moved to
    */
    public static ArrayList<Point> getMoves(Point p) {
        ArrayList<Point> moves = new ArrayList<>();

        // add all moves including invalid
        moves.add(new Point(p.x-2, p.y+1));
        moves.add(new Point(p.x-2, p.y-1));
        moves.add(new Point(p.x+2, p.y+1));
        moves.add(new Point(p.x+2, p.y-1));

        moves.add(new Point(p.x-1, p.y+2));
        moves.add(new Point(p.x-1, p.y-2));
        moves.add(new Point(p.x+1, p.y+2));
        moves.add(new Point(p.x+1, p.y-2));

        // trim off invalid moves
        for(int i = 0; i < moves.size(); i++) {
            if(moves.get(i).x < 0 || moves.get(i).x > 7 || moves.get(i).y < 0 || moves.get(i).y > 7) {
                moves.remove(i);
                i--;
            }
        }
        return moves;
    }


    /*
     * prints a 2d representation matrix m
     */
    private static void printMatrix(int[][] m) {
        for (int i = 0; i < m.length; i++) {
            for (int j = 0; j < m[i].length; j++) {
                System.out.print(m[i][j] + "\t");
            }
            System.out.println();
        }
    }


    /*
     * Initializes a the game board
     * returns int[][] with each element containing the number of
     * possible moves to get to that position
     */
    public static int[][] initBoard() {
        int[][] m = new int[8][8];
        for(int i = 0; i < m.length; i++) {
            for(int j = 0; j < m.length; j++) {
                // init to all 0
                m[i][j] = getMoves(new Point(i,j)).size();
            }
        }
        return m;
    }
}



/*
 * wrap an int in an object so that it is mutable and can change as we recursively call our search algorithm
 */
class MutableInt {

    int value;

    public MutableInt(int value) {
        this.value = value;
    }
    public void add(int operand) {
        value += operand;
    }
    public int get() {
        return value;
    }
}
